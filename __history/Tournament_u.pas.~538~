unit Tournament_u;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants,
  System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.ComCtrls, DMUnit_u,
  Utils_u, Math;

type
  TfrmTournament = class(TForm)
    lstAllocations: TListBox;
    cmbRound: TComboBox;
    redTeams: TRichEdit;
    btnBack: TButton;
    btnBeginTournament: TButton;
    btnNextRnd: TButton;
    procedure lstAllocationsClick(Sender: TObject);
    procedure FormClose(Sender: TObject; var Action: TCloseAction);
    procedure btnBackClick(Sender: TObject);
    procedure FormShow(Sender: TObject);
    procedure displayAllocs();
    procedure cmbRoundChange(Sender: TObject);
    procedure btnBeginTournamentClick(Sender: TObject);
    procedure makeFixtures(arr: TArray<string>; Round: integer);
    procedure saveTournament();
    procedure btnNextRndClick(Sender: TObject);
    function calcByes(iTeams : integer) : integer;
  private
    { Private declarations }
  public
    { Public declarations }
    sID: string;
    iUser, iNumRounds: integer;
    bBegin: boolean;
  end;

var
  frmTournament: TfrmTournament;
  // these dynamic arrays allow for all the relevant data
  // to be retrieved once a user accesses frmMatch
  // by storing the MatchIDs and AllocIDs in parallel.
  arrMatchID, arrAllocID, arrWB, arrLB: TArray<string>;
  util: Utils;
  iRound: integer;
  fTournament: TextFile;

const
  fileName = 'Tournament.txt';

implementation

uses
  Match_u,
  Main_u;

{$R *.dfm}

procedure TfrmTournament.btnBackClick(Sender: TObject);
begin
  frmMain.Show;
  frmTournament.Hide;
end;

procedure TfrmTournament.FormClose(Sender: TObject; var Action: TCloseAction);
begin
  Application.Terminate;
end;

procedure TfrmTournament.FormShow(Sender: TObject);
var
  I: integer;
begin
  // open tables
  with DataModule1 do
  begin
    MatchTB.Open;
    MatchAllocTB.Open;
    TeamTB.Open;

    // add rounds to the combo box

    // TODO: FIX
    cmbRound.Items.Clear;
    for I := 1 to iNumRounds do
    begin
      cmbRound.Items.Add(intToStr(I));
    end;

    // update list box
    displayAllocs();

    // populate wb and lb
    TeamTB.Filter := 'NumLost = 0';
    TeamTB.Filtered := true;
    TeamTB.First;
    I := 0;
    while not TeamTB.Eof do
    begin
      I := I + 1;
      setLength(arrWB, I);
      arrWB[I - 1] := TeamTB['TeamName'];
      showMessage(arrWB[I - 1]);
      TeamTB.Next;
    end;
    TeamTB.Filter := 'NumLost = 1';
    TeamTB.First;
    I := 0;
    while not TeamTB.Eof do
    begin
      I := I + 1;
      setLength(arrLB, I);
      arrLB[I - 1] := TeamTB['TeamName'];
      TeamTB.Next;
    end;
    TeamTB.Filtered := false;

    // Only allows the next round to be started if all matches are over
    MatchTB.Filter := 'MatchDate > ' + DateToStr(Date);
    MatchTB.Filtered := true;
    btnNextRnd.Enabled := MatchTB.RecordCount = 0;

  end;

end;

procedure TfrmTournament.lstAllocationsClick(Sender: TObject);
var
  Index: integer;
begin
  case lstAllocations.ItemIndex of
    - 1:
    else
    begin
      with DataModule1 do
      begin
        // passes selected MatchID and associated AllocIDs to Match Screen
        index := lstAllocations.ItemIndex;
        frmMatch.matchID := arrMatchID[index];
        setLength(frmMatch.arrAllocID, 2);
        frmMatch.arrAllocID[0] := arrAllocID[index * 2];
        frmMatch.arrAllocID[1] := arrAllocID[(index * 2) + 1];
        frmMatch.iUser := iUser;
        frmMatch.sID := sID;

        frmMatch.Show;
        frmTournament.Hide;

      end;
    end;
  end;
end;

function tfrmTournament.calcByes(iTeams: Integer) : integer;
var
iByes ,iPower , iHighestPower, iPrevPower: integer;
begin
  iByes := 0;
  iPower := 1;
  while iTeams > trunc(power(2,iPower)) do
    begin
      iPower := iPower + 1;
    end;
    if iTeams =  trunc(power(2,iPower)) then
    begin
       Result:=  0;
    end
    else
    begin

    end;
end;

procedure TfrmTournament.makeFixtures(arr: TArray<string>; Round: integer);
var
  arrTeams, arrByes: TArray<string>;
  arrMatchTeams: array [0 .. 1] of string;
  dDate: TDateTIme;
  sMatchID, sAllocID: string;
  I, J, iHighestPower, iByes, iTeams, iPower: integer;
  bFoundRecord: boolean;
begin
  // TODO: RANDOMISE PICKING TEAMS
  with DataModule1 do
  begin
    iTeams := length(arr);

    iByes := 0;

    iPower := 1;


    dDate := Date;

    // get teams and byes
    //PROBLEM WITH BYES
    for I := 0 to length(arr) - 1 do
    begin
      bFoundRecord := util.goToRecord(MatchAllocTB, 'TeamName', arr[I]) = 1;
      showMessage(arr[I]);
      if (bFoundRecord) then
      begin
        if (MatchAllocTB['MatchID'] = '') then
        begin
          iByes := iByes + 1;
          showMessage('Test1');
          setLength(arrByes, iByes);
          arrByes[iByes - 1] := arr[I];
        end
        else
        begin
          iTeams := iTeams + 1;
          showMessage('Test2');
          setLength(arrTeams, iTeams);
          arrTeams[iTeams - 1] := arr[I];
        end;
      end // if
      else
      begin
        iTeams := iTeams + 1;
        showMessage('Test22');
        setLength(arrTeams, iTeams);
        arrTeams[iTeams - 1] := arr[I];
      end;
    end;

    MatchAllocTB.First;

    iPower := 1;
    while iTeams + iByes - power(2, iPower) >= 0 do
    begin
      iPower := iPower + 1;
    end;

    iHighestPower := trunc(power(2, (iPower - 1)));

    I := 0;
    while I < iHighestPower / 2 do
    begin
      dDate := dDate + 4;

      // check byes first
      if I <= iByes - 1 then
      begin
        showMessage('Test3');
        arrMatchTeams[0] := arrTeams[I];
        arrMatchTeams[1] := arrByes[I];
      end
      else
      begin
        showMessage('teamOne: ' + arrTeams[2 * I]);
        arrMatchTeams[0] := arrTeams[2 * I];
        showMessage('teamTwo: ' + arrTeams[2 * I + 1]);
        arrMatchTeams[1] := arrTeams[2 * I + 1];
      end;

      // Generate unique primary key
      showMessage('woop');

      Repeat
      begin
        sMatchID := UpCase(arrMatchTeams[0][1]) + UpCase(arrMatchTeams[1][1]) +
          intToStr(random(10));
      end
      until not util.isInTable(MatchTB, 'MatchID', sMatchID);

      MatchTB.Last;
      MatchTB.insert;
      MatchTB['MatchID'] := sMatchID;
      MatchTB.Edit;
      MatchTB['Location'] := 'Idk';
      MatchTB.Edit;
      MatchTB['MatchDate'] := dDate;
      MatchTB.Edit;
      MatchTB['Round'] := Round;

      MatchTB.Edit;
      MatchTB.Post;
      MatchTB.Refresh;

      // create matchalloc records
      for J := 0 to 1 do
      begin
        repeat
          sAllocID := UpCase(arrMatchTeams[J][1]) + intToStr(random(10)) +
            intToStr(random(10));
        until not util.isInTable(MatchAllocTB, 'AllocID', sAllocID);

        MatchAllocTB.Last;
        MatchAllocTB.insert;

        MatchAllocTB['AllocID'] := sAllocID;
        MatchAllocTB.Edit;
        MatchAllocTB['TeamName'] := arrMatchTeams[J];
        MatchAllocTB.Edit;
        MatchAllocTB['Won'] := false;
        MatchAllocTB.Edit;
        MatchAllocTB['Score'] := 0;
        MatchAllocTB.Edit;
        MatchAllocTB['MatchID'] := sMatchID;
      end;

      I := I + 1;
    end;

    // create Records for byes

    showMessage('Sneedy');

    {while I < (iTeams + iByes) do
    begin
      repeat
        sAllocID := UpCase(arrTeams[I][1]) + intToStr(random(10)) +
          intToStr(random(10));
      until not util.isInTable(MatchAllocTB, 'AllocID', sAllocID);

      MatchAllocTB.Last;
      MatchAllocTB.insert;

      MatchAllocTB['AllocID'] := sAllocID;
      MatchAllocTB.Edit;
      MatchAllocTB['TeamName'] := arrTeams[I];
      MatchAllocTB.Edit;
      MatchAllocTB['Won'] := false;
      MatchAllocTB.Edit;
      MatchAllocTB['Score'] := 0;
      MatchAllocTB.Edit;
      showMessage('Woopy');
      MatchAllocTB['MatchID'] := NullAsStringValue;
      showMessage('Woopy1');
    end;
    }

    // Update DB
    MatchAllocTB.Edit;
    MatchAllocTB.Post;
    MatchAllocTB.Refresh;
    MatchAllocTB.First;

    MatchTB.Edit;
    MatchTB.Post;
    MatchTB.Refresh;
    MatchTB.First;

  end;

end;

procedure TfrmTournament.btnBeginTournamentClick(Sender: TObject);
begin
  iRound := 1;
  makeFixtures(arrWB, iRound);

  btnBeginTournament.Enabled := false;

  saveTournament();
end;

procedure TfrmTournament.btnNextRndClick(Sender: TObject);
begin

  iRound := iRound + 1;

  makeFixtures(arrWB, iRound);

  saveTournament();

end;

procedure TfrmTournament.cmbRoundChange(Sender: TObject);
begin
  displayAllocs();
end;

procedure TfrmTournament.displayAllocs();
var
  I: integer;
  sItem: string;
  dDate: TDateTIme;
begin
  //
  if not(cmbRound.ItemIndex = -1) then
  begin
    with DataModule1 do
    begin
      // check textfile
      if not(cmbRound.ItemIndex = -1) then
        iRound := strToInt(cmbRound.Items[cmbRound.ItemIndex]);

      lstAllocations.Items.Clear;

      // query for matchID that are in the selected round
      setLength(arrMatchID, 0);
      setLength(arrAllocID, 0);

      MatchTB.First;
      I := 0;
      while not MatchTB.Eof do
      begin

        if MatchTB['Round'] = iRound then
        begin
          setLength(arrMatchID, length(arrMatchID) + 1);
          arrMatchID[I] := MatchTB['MatchID'];

          dDate := MatchTB['MatchDate'];

          // Loops through the two allocations related to a match record
          // in order to create a list box item
          // This also makes it possible for the list box item to give relevant
          // data to frmMatch
          setLength(arrAllocID, length(arrMatchID) * 2);
          MatchAllocTB.First;

          sItem := '';

          util.goToRecord(MatchAllocTB, 'MatchID', arrMatchID[I]);
          arrAllocID[(2 * I)] := MatchAllocTB['AllocID'];
          sItem := sItem + MatchAllocTB['TeamName'] + ' vs ';
          util.goToNextRecord(MatchAllocTB, 'MatchID', arrMatchID[I]);
          arrAllocID[(2 * I) + 1] := MatchAllocTB['AllocID'];
          sItem := sItem + MatchAllocTB['TeamName'] + ' on ' + DateToStr(dDate);

          lstAllocations.Items.Add(sItem);

          I := I + 1;
        end;
        MatchTB.Next;
      end;
      MatchTB.First;
      MatchAllocTB.First;

    end;

  end;

end;

// Save the state of the tournament to a text file
procedure TfrmTournament.saveTournament();
begin
  AssignFile(fTournament, fileName);

  ReWrite(fTournament);
  if bBegin then
  begin
    Writeln(fTournament, 'Begun: T');
  end
  else
    Writeln(fTournament, 'Begun: F');

  Writeln(fTournament, 'CurrentRound: ' + intToStr(iNumRounds));

  CloseFile(fTournament);

end;

end.
